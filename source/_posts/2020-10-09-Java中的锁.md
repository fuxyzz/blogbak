---
title: Java中的锁
date: 2020-10-09 15:02:18
categories: [Java,lock]
tags: [Java,lock]
---
# 乐观锁和悲观锁
在了解java中的锁之前，我们需要先了解乐观锁和悲观锁。

悲观锁是指数据并发的时候，认为在使用数据的时候会有其他线程来修改数据，因此在获取数据的时候会进行加锁。

乐观锁是指数据并发的时候，乐观锁认为在使用数据的时候不会有其他线程来修改数据，因此只在更新数据的时候判断有没有其他线程更新了数据（ABA问题可以用时间戳或者版本号解决）。

应用场景：乐观锁适合读多写少，不加锁的特点使得性能能够大幅提升。悲观锁适合写多读少，先加锁可以保证写操作数据正确。

# java中的锁实现

### 乐观锁
通过无锁编程，常用的是CAS算法实现，例如并发包下的Atomic包下的类，例如AtomicInteger，通过CAS自旋实现。

CAS全称Campare And Swap，在不使用锁的情况下实现多线程的变量同步。CAS涉及三个操作：

（1）读取需要读写的内存值

（2）比较值

（3）写入新值

底层操作系统通过类似原语的原子操作保证比较和写入是一个原子操作，一般情况下写入是不断重试的操作。

举个例子：AtomicInteger的getAndIncrement方法。

```
    public final int getAndAddInt(Object var1, long var2, int var4) {
        int var5;
        do {
            var5 = this.getIntVolatile(var1, var2);
        }
        //自旋直至成功
        while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

        return var5;
    }
```
CAS存在的问题：

（1）CAS会引起ABA问题，JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题。

（2）自旋开销问题，如果长时间CAS操作不成功，会一直自旋，浪费CPU资源。

（3）保证一个共享变量的原子性，不能保证多个变量操作时的原子性。Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。

关于自旋：唤醒或阻塞一个线程需要操作系统切换CPU，这种状态转换需要耗费处理器的时间，如果同步代码块中的内容非常简单，状态转换时间有可能比用户代码执行时间还要长。很多场景下，同步资源等待锁的情况很少，为了一小段时间去切换线程，非常的得不偿失。如果有多个CPU，能够让两个或以上的线程同时并行的执行，就可以让后请求的线程不阻塞不放弃CPU的执行时间，等待前面的线程是否很快就会释放锁。自旋锁有限制次数，默认是10次，可以用-XX:PreBlockSpin更改，如果达到限制次数没有成功获得锁，就需要阻塞线程（或者说挂起吧）。

自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中为默认开启，并且引入了适应性自旋锁。

自适应的意思是自旋的次数不再固定，由上一次在同一个锁上自旋次数及拥有者的状态来决定。如果在同一个锁对象上自旋等待成功获得过锁，并且拥有锁的线程在运行中，那么JVM认为很可能再次成功获取锁，允许将这次的自旋次数提高。如果对于某个锁，自旋很少成功，后面尝试获取这个锁的时候获取失败直接阻塞，不进行自旋操作。

自旋锁常见的锁形式：TicketLock、CLHlock和MCSlock。

### 悲观锁

### Synchronized
Synchronized在JDK1.6以前是悲观锁的实现，1.6引入了无锁，偏向锁，轻量级锁，重量级锁。由于无锁是CAS实现的乐观锁，1.6不能单纯的将Synchronized认为是悲观锁。

先探究一下Synchronized实现线程同步的原理。主要依赖两个东西，JAVA对象头和Monitor。

JAVA对象头在Hotspot虚拟机里包含两部分数据，Mark Word（标记字段），Klass Pointer（类型指针）。

Mark Word：默认存储对象的HashCode，分代年龄，锁标志位信息。存储的都是与对象自身无关的信息，运行期间Mark Word的信息会根据锁状态的不同发生改变。

Klass Pointer：对象指向它类元数据的指针，JVM通过它确定对象是哪个类的实例。

Monitor：一种同步机制，依赖底层操作系统的Mutex Lock（互斥锁）实现线程同步。每个JAVA对象都有一把Monitor锁。Monitor是线程私有的数据结构，每个线程都有Monitor Record列表，同时有全局共享的可用列表。每一个被锁的对象都会和一个Monitor关联，同时Monitor有一个Owner字段存放拥有该锁的线程的唯一标志，表示锁被该线程占用。

锁状态及Mark Word对于标志位

| 锁状态 | 存储内容 | 标志位 |
|:---:|:---:|:---:|
|无锁 | 对象HashCode，分代年龄，偏向锁标志位（0） | 01|
|偏向锁 | 偏向线程，偏向时间戳，分代年龄，偏向锁标志位（1） | 01|
|轻量级锁 | 执行栈中锁记录的指针 | 00|
|重量级锁 | 指向重量级锁的指针 | 10|
|GC标志 | 空，没有记录信息 | 11|

无锁：

多个线程都能访问和修改同一个资源，只有一个成功，底层依赖CAS实现。

偏向锁：

一段同步代码块一直被一个线程访问，那么该线程就会自动获取锁，降低获取的代价。应用的场景是在无多线程竞争的场景下尽量减少不必要的轻量级锁执行，因为执行的过程设计多次的获取和释放CAS原子指令，偏向锁通过更新偏向线程ID的时候执行一次CAS指令即可。

偏向锁只有在其他线程尝试竞争偏向锁的时候释放锁，线程不会主动释放偏向锁。偏向锁释放时机在全局安全点，先暂停拥有偏向锁的线程，判断对象是否处于锁定状态。释放偏向锁后升级为轻量级锁状态。

1.6以后默认开启，可以用-XX:-UseBiasedLocking=false关闭。

轻量级锁：

当锁是偏向锁的时候，被另外的线程访问，偏向锁就会升级为轻量级锁。其他线程会使用自旋锁获取锁资源，提高性能。

代码进入同步块的时候，如果对象的锁状态为无锁状态，JVM在当前线程的栈帧中建立一个Lock Record列表，存储对象目前Mark Word的副本。

存储对象Mark Word副本成功后，使用CAS指针将对象的Mark Word更新为指向Lock Record的指针，将Lock Record的Owner指针指向对象的Mark Word。

如果更新成功，线程就拥有了锁资源。

如果更新失败，JVM先检查对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已经拥有了锁资源，继续执行，否则说明处于多线程竞争中。

如果只有一个等待线程，线程通过自旋等待锁资源。如果自旋次数超过限制次数，或者一个线程在持有锁，一个在自旋，此时又有更多线程尝试获取锁资源，则升级为重量级锁。

重量级锁：

Mark Word中存储指向重量级锁的指针，等待的线程都会进入阻塞状态。


结论及注意事项：

（1）锁只能升级不能降级

（2）从上述的描述很容易看出锁是对象级别的，不是所有对象都是同一锁级别的

（3）偏向锁通过对比Mark Word解决锁问题，减少CAS操作

（4）轻量级锁通过CAS操作和自旋解决锁问题，避免线程阻塞和唤醒影响性能

（5）重量级锁将拥有锁以外的线程全部阻塞

### ReentrantLock

ReentrantLock底层实现了公平锁和非公平锁，默认使用非公平锁。

公平锁是按申请锁的时间顺序获取锁，进入队列等待获取，公平锁的优点是不会造成饿死现象。缺点是吞吐效率相对非公平锁要低，等待队列中除了第一个线程外其他线程全部阻塞，CPU唤醒阻塞线程的开销比非公平锁要大。

非公平锁是多个线程加锁时直接获取锁，获取不到才会到等待队列中进行排队，如果此时锁刚好可用就无需阻塞直接获取到锁，所以非公平锁可能会出现后申请锁资源却先获取到锁资源的情况。非公平锁的优点是减少唤起线程的开销，整体的吞吐率更高，因为线程有几率不阻塞直接获取锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等待很久才会获得锁。

在源码中，公平锁比非公平锁在获取锁的时候多了一个判断，通过hasQueuedPredecessors判断当前线程是否处于队列的头部。

```
    public final boolean hasQueuedPredecessors() {
        // The correctness of this depends on head being initialized
        // before tail and on head.next being accurate if the current
        // thread is first in queue.
        Node t = tail; // Read fields in reverse initialization order
        Node h = head;
        Node s;
        return h != t &&
            ((s = h.next) == null || s.thread != Thread.currentThread());
    }
```

总结一下：公平锁是排队，非公平锁是插队。

### 可重入锁

可重入锁又名递归锁，指同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提是同一个对象或者class），不会因为之前获取过还没释放而阻塞。Synchronized和ReentrantLock都是可冲入锁，可重入锁可以一定程度上避免死锁。

### 共享锁和排他锁

共享锁是指锁可以被多个线程持有，如果线程A对数据Data加了共享锁后，其他线程也只能对Data加共享锁，不能加排他锁。获取共享锁的线程只能读，不能修改Data。

排他锁是指锁只能被一个线程持有，如果给一个数据加上排他锁，其他线程不能对数据再加上任何类型的锁。获得排他锁的线程既可以读也可以写。Synchronized和ReentrantLock都是排他锁。

ReentrantReadWriteLock实现了共享锁和排他锁，内部有两把锁，ReadLock和WriteLock。ReadLock就是读锁，是共享锁的实现，WriteLock是写锁，是排他锁的实现。

在AQS中有个int变量state，表示多少线程获取了锁。在排他锁的情况下，这个变量是0或者1（如果是可重入锁state表示重入的次数），共享锁中就是持有锁的数量。在ReentrantReadWriteLock的实现中，直接将state变量对半切分了，高16位用于统计读锁个数，低16位用于统计写锁个数。

### 总结
所有的锁最终都是用到了CAS进行数据保证，甚至利用CAS避免线程阻塞使得从用户态切换到内核态，但是为了尽可能的减少CAS操作（因为涉及到缓存失效，其他线程需要从主存中重新获取，开销挺大），做了其他的一些优化。Synchronized和ReentrantLock效率上在JDK1.6版本以后几乎没有性能的差距，在并发量不高的情况下Synchronized也许效率会更高。
